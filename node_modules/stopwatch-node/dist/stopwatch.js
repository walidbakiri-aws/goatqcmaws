"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StopWatch = void 0;
const taskinfo_1 = require("./taskinfo");
class StopWatch {
    constructor(id = '') {
        this.currentTaskName = null;
        this.startTimeMillis = 0;
        this.totalTimeMillis = 0;
        this.taskList = [];
        this.id = id;
    }
    /**
     * start a task
     */
    start(taskName = '') {
        this.currentTaskName !== null && this.throwError('Can\'t start StopWatch: it\'s already running');
        this.currentTaskName = taskName;
        this.startTimeMillis = Date.now();
    }
    /**
     * stop the current task
     */
    stop() {
        this.currentTaskName === null && this.throwError('Can\'t stop StopWatch: it\'s not running');
        const lastTime = Date.now() - this.startTimeMillis;
        this.totalTimeMillis += lastTime;
        const lastTaskInfo = new taskinfo_1.TaskInfo(this.currentTaskName, lastTime);
        this.taskList.push(lastTaskInfo);
        this.currentTaskName = null;
    }
    /**
     * Return a string with a table describing all tasks performed.
     */
    prettyPrint() {
        const output = [this.shortSummary()];
        if (this.taskList.length) {
            output.push('------------------------------------------');
            output.push('ms \t\t % \t\t Task name');
            output.push('------------------------------------------');
            this.taskList.forEach((task) => {
                let percentage = '0';
                try {
                    percentage = task.calculatePercentage(this.totalTimeMillis);
                }
                catch (e) {
                }
                output.push(`${task.timeMills} \t\t ${percentage} \t\t ${task.taskName}`);
            });
        }
        else {
            output.push(StopWatch.NoTaskMessage);
        }
        const outputString = output.join('\n');
        console.info(outputString);
        return outputString;
    }
    /**
     * Return a task matching the given name
     */
    getTask(taskName) {
        const task = this.taskList.find(task => task.taskName === taskName);
        task === null || task === void 0 ? void 0 : task.calculatePercentage(this.totalTimeMillis);
        return task;
    }
    /**
     * Return the total running time in milliseconds
     */
    getTotalTime() {
        return this.totalTimeMillis;
    }
    /**
     * Return a short description of the total running time.
     */
    shortSummary() {
        return `StopWatch '${this.id}' running time (millis) = ${this.totalTimeMillis}`;
    }
    /**
     * Return whether the stop watch is currently running
     */
    isRunning() {
        return this.currentTaskName !== null;
    }
    /**
     * Return the number of tasks timed.
     */
    getTaskCount() {
        return this.taskList.length;
    }
    throwError(msg) {
        throw new Error(msg);
    }
}
exports.StopWatch = StopWatch;
StopWatch.NoTaskMessage = 'No task info kept';
//# sourceMappingURL=stopwatch.js.map